design.txt

Python is going to be the first output language, so that AQA
style Pseudo code can be converted into first-cut python
for further development. This will be useful for school children
to develop the basis of an algorithm in pseudo code, and then
convert this into Python to further develop it.

JUST DONE
Added code to check for read past end of file.

--------------------------------------------------------------------------------
TODO - ARRAYS

SPEC
globals allowed
locals allowed in fnproc
no fnproc nesting
no scopes local to if/else/case etc
not possible to create globals inside a fn/proc.
possible to create globals inside a top level scope
Array copy, yes
  a <- [1,2,3]
  b <- b
  OUTPUT b[2]

  b is an independent copy of a (not a reference to it).
  This could be quite computationally expensive with large arrays,
  but the semantics are simpler to explain as they are consistent
  with scalar variables.


DESIGN

A list of variables in the global scope. Lifetime for the runtime of the program.
    global_varnames = []

A list of variables in local scope of present fn/proc being parsed, lifetime for the
execution of that fn/proc.
    local_varnames = []

When reading an array variable:
  if it is not defined in local or global
    raise an undefined variable error.

When writing to an array variable:
  if we are not in a fnproc,
    check global_varnames
    if not known,
      if this is a 1D array, generate Array()
      if this is a 2D array, generate Array2D()
      add to global_varnames
  else we are in a fnproc
    check local_varnames
    if not known,
      if this is a 1D array, generate Array()
      if this is a 2D array, generate Array2D()
      add to local_varnames

When initialising an array variable:
  if not in fnproc
   check global_varnames
   if not known,
     create Array()
     add to global_varnames
  if is fnproc
    check local_varnames
    if not known,
      crate Array()
      add to local_varnames

When starting a new fnproc defn:
  empty the local_varnames

When ending a fnproc defn:
  empty the local_varnames



array deep copy - this is tricky, need to know at runtime that it is an
array and not somethign else, and then do the deep copy.
Is there a pythonic way with a meta method to detect a copy and make it
deep rather than a reference??


--------------------------------------------------------------------------------
TODO - runtime embedding

* run an experiment to work out the best way to embed a whole
  python module inside a python module, so that it can be
  programatically streamed out when embedded in a zip file.
  Code it up manually, be careful of escaping quotes etc.

* work out what the interface to this module is - probably
  just call a function with a file handle, and it appends it's
  docstring contents to that file handle (much better than returning
  a string and then writing that, more efficient)

* write a tool that embeds all of the files in a nominated folder
  into a single python file as big docstrings - this will be useful
  for embedding code into a zip package in a way that it can then
  just be streamed out on demand to another file in the filing system.
  Be careful of escaping quotes etc properly.

* Put this tool in the build dir

* Change the build script so that it runs this on the runtime folder
  and generates a runtime.py

* work out path to user script when parser runs

* Test that we can put this inside a zip file, run the zip file
  from python and it generates

* on parser run, auto copy io.py and array.py to user script dir
  (use file read/write rather than copy, so it works from within zip?
  need to verify we can find a way to read resources from a zip, might
  have to embed the code as a docstring so that we can read it out
  as a resource, in case the .zip is execute only.)

* auto import io.py and array.py at top of every program

--------------------------------------------------------------------------------
PACKAGING AND DISTRIBUTION

Need to test this works with python2 and python3

Look into packaging the whole thing as a zip file with a __main__.py inside it,
and check that this works with both python2 and python3 - i.e. can we just
run python pcode.zip myprog.aqa on any platform and it will work?

The aqa_io.py and aqa_array.py modules will be embedded inside a folder in the zip
and bytestream'ed out into the user script directory every time they run the tool.
That way if they damage the file, it will be replaced on each build.




I *think* when we get here, the project is finished.






