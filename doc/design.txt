design.txt

Design of a grammar suitable for use with PLY.
First cut grammar with rough notes...

Notes
- no explicit string expressions in their grammar?
- but can assign string literals to variables
- no obvious way to concatenate strings
- userinput accepts numbers and strings
- output accepts numbers and strings

lexer
=====

whitespace 0 or more: [space, tab, newline]

# comment to end of line

IF THEN ELSE ENDIF WHILE ENDWHILE CASE OF ENDCASE FOR TO ENDFOR REPEAT UNTIL
FUNCTION ENDFUNCTION RETURN PROCEDURE ENDPROCEDURE
READLINE WRITELINE OUTPUT USERINPUT LEN
MOD NOT FALSE TRUE AND OR XOR
+ - * /
= <> < <= > >=
<-
[ ]
,
( )
:
"

NUMBER



grammar
=======

program:
      /* empty */
    | statements
    ;

statements:
      /* empty */
    | statement
    | statements statement
    ;

statement:
      if-statement
    | while-statement
    | case-statement
    | for-statement
    | repeat-statement
    | function-def-statement
    | return-statement
    | procedure-def-statement
    | proc-call-statement
    | writeline-statement
    | output-statement
    | var-assignment-statement
    | array-assignment-statement
    | array2d-assignment-statement
    | array-initialiser-statement
    ;

# beware of dangling else problem

if-statement:
      IF bexpr THEN statements ENDIF
    | IF bexpr THEN statements ELSE statements ENDIF
    ;

while-statement:
    WHILE bexpr statements ENDWHILE
    ;

case-option:
    expr : statements
    ;

case-options:
      case-option
    | case-options case-option
    ;

case-statement:
    CASE expr OF case-options
    ELSE statements ENDCASE

for-statement:
    FOR var <- iexpr1 TO iexpr2
    statements
    ENDFOR

repeat-statement:
    REPEAT
    statements
    UNTIL bexpr

funproc-def-params:
      /* empty */
    | expr
    | funproc-def-params , expr
    ;

# fname??

function-def-statement:
    FUNCTION fname ( funproc-def-params )
    statements
    ENDFUNCTION
    ;

# beware of ambiguity of where return is and is-not allowed
return-statement:
    RETURN expr

# pname??

procedure-def-statement:
    PROCEDURE pname ( funproc-def-params )
    statements
    ENDPROCEDURE
    ;

fnproc-call-params:
      /* empty */
    | expr
    | fnproc-call-params , expr
    ;

# beware of ambiguity between fn call and proc call
proc-call-statement:
    pname ( fnproc-call-params )
    ;

fn-call-statement:
    fname ( fnproc-call-params )
    ;

# file?

readline-statement:
    READLINE ( file, iexpr )
    ;

writeline-statement:
    WRITELINE(file, iexpr, expr )
    ;

output-statement:
    OUTPUT texpr
    ;

#varname?

var-assignment-statement:
    varname <- expr
    ;

array-assignment-statement:
    varname [ iexpr ] <- expr
    ;

array2d-assignment-statement:
    varname [ iexpr1 ] [ iexpr2 ] <- expr
    ;

initialiser-expression:
      /* empty */
    | expr
    | initialiser-expression , expr
    ;

array-initialiser-statement:
    varname <- [ initialiser-expr]
    ;

# can be any type of expression (iexpr, texpr, bexpr)
# presumably type is stored along with the value

expr:
      iexpr
    | bexpr
    | texpr
    | fn-call-statement
    | readline-statement
    ;

# note, define precedence in the hierarchy of the grammar
# note, unary minus
# note, unary plus

iexpr:
      ( iexpr )
    | NUMBER
    | LEN(var)
    | USERINPUT
    | iexpr
    | iexpr + iexpr
    | iexpr - iexpr
    | iexpr * iexpr
    | iexpr / iexpr
    | iexpr MOD iexpr
    | - iexpr
    | + iexpr
    ;

texpr:
    " text "
    ;

# note, define precedence in the hierarchy of the grammar

bexpr:
      TRUE
    | FALSE
    | ( bexpr )
    | NOT bexpr
    | bexpr AND bexpr
    | bexpr OR bexpr
    | bexpr XOR bexpr
    | iexpr = iexpr
    | iexpr <> iexpr
    | iexpr <= iexpr
    | iexpr >= iexpr
    | iexpr > iexpr
    | iexpr < iexpr
    ;

# END