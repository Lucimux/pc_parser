design.txt

Python is going to be the first output language, so that AQA
style Pseudo code can be converted into first-cut python
for further development. This will be useful for school children
to develop the basis of an algorithm in pseudo code, and then
convert this into Python to further develop it.

JUST DONE
added to grammar, read expression a[expr]
addded to grammar, read expression a[expr][expr]


----- I/O

ANALYSIS
The runtime helpers have been written, so semantics are known.

If the parser senses use of a READLINE, it needs to insert the readline()
function at the top of the generated python. This is mucky as it implies
a two pass generation process.

We could always import aqaio which has a readline and writeline
implementation in it, but then for simple programs, this makes the python
look more complex than it needs to be. It also means that you have to have
a copy of the runtime modules for this to work.

The runtime modules could be auto-generated in the script folder if
needed - this would then mean that the import is optional, and the two
pass generation is still required.

Could always auto generate and always import on every build. That way
the generated python would look quite simple, you wouldn't have to
keep copies of the runtime files yourself.

SPEC

Put this at the top of every generated file

from aqa_io import * # readline() and writeline()

Have a copy of the aqa_io.py inside the package, and just
open the file, read it, and write it to the script directory.
This way the copy is platform independent.

DESIGN
* work out path to user script
* read/write file aqa_io.py from package directory into user script directory
* write test cases for readline
* write test cases for writeline
* write code for readline
* write code for writeline
* test both





----- ARRAYS

SPEC
globals - are we going to allow them? Yes.
Simpler model than python, i.e. if you define a variable in global
scope, it is globally accessible as read/write.

If you define a variable in any local scope, it's lifetime lasts
for the fn/proc that it was defined in, and it's visibility is limited
to that function.

It's not possible to create globals inside a fn/proc.

It is possible to create globals inside a top level scope (e.g. an 'if'
at the outer level).

Nesting is two level only - outer scope (global) and fn/proc scope (local).
fn/proc's are disallowed from being nested.

Are we going to allow array copy? Yes, deep copy.

i.e.
a <- [1,2,3]
b <- b
OUTPUT b[2]

b is an independent copy of a (not a reference to it).
This could be quite computationally expensive with large arrays,
but the semantics are simpler to explain as they are consistent
with scalar variables.


DESIGN

Put this at the top of every generated file:

from aqa_array import * # Array() and Array2D()

Have a copy of the aqa_array.py inside the package, and just
open the file, read it, and write it to the script directory.
This way the copy is platform indepenent.



A list of variables in the global scope. Lifetime for the runtime of the program.

A list of variables in local scope of present fn/proc, lifetime for the
execution of that fn/proc.

If you call another fn/proc, a new local scope is created, and you can only
see variables in global scope and the present local scope (i.e. no nested
scope visibility).

Thus, we can't use the nest stack as that is used for IF/ELSE also. We
need a separate fnproc stack

When reading a variable, if it is not defined, can raise an undefined variable error.
This might also be possible at compile time as it is known.

When writing to a variable, if it is not in the list of defined live variables,
then generate an initialisation and add it to the list.


auto generate 1d array constructor call Array()
auto generate 2d array constructor call Array2D()
auto generate array init constructor call Array()

detect use of any arrays, and import array module only if it is needed.
Auto generate the array module file from parser text, so users don't need
to have an extra file (perhaps just copy the file from a file in the project dir?)



----- PACKAGING AND DISTRIBUTION

Need to test this works with python2 and python3

Look into packaging the whole thing as a zip file with a __main__.py inside it,
and check that this works with both python2 and python3 - i.e. can we just
run python pcode.zip myprog.aqa on any platform and it will work?

The aqa_io.py and aqa_array.py modules will be embedded inside a folder in the zip
and bytestream'ed out into the user script directory every time they run the tool.
That way if they damage the file, it will be replaced on each build.




I *think* when we get here, the project is finished.






